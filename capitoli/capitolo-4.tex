% !TEX encoding = UTF-8
% !TEX TS-program = pdflatex
% !TEX root = ../tesi.tex

%**************************************************************
\chapter{Conclusioni}
\label{cap:conclusioni}

\section{Riflessioni finali}
I risultati ottenuti ed esposti in \ref{cap:performance} sono spunto di alcune riflessioni.\\

Ragionando sulla miglioria $CCC$, ci possiamo rendere conto di due cose: la prima è che per istanze semplici del problema (Livelli 0,1 e 2) essa non migliora il tempo di esecuzione degli algoritmi di $Backtracking$, ma addirittura arriva anche a raddoppiarlo. Su istanze molto complesse (Livello 4), il $CCC$ risulta essere invece determinante nella riduzione del tempo di esecuzione di tali algoritmi: il $Backtracking$ è tre più veloce, mentre il \textit{Recursive Backtracking} quasi il doppio. \\
La seconda, invece, è che per l'algoritmo $DFS$ è sempre meglio utilizzare il $CCC$, in quanto permette di ignorare totalmente una buona parte dei cammini che non portano ad uno stato obiettivo, come esposto in \ref{oss0}.\\

Per quanto riguarda la miglioria $RR$ per $MinConflicts$, potrebbe in un primo momento sembrare poco efficiente visto il suo tempo di esecuzione nettamente più alto rispetto agli altri algoritmi. Questo è dovuto al fatto che la presenza di minimi locali rende necessario riavviare l'algoritmo, compromettendone così le performance. Tuttavia, lo scopo principale di questa miglioria non è volto a diminuire il tempo di esecuzione, bensì rendere $MinConflict$ un algoritmo completo, cioè in grado di arrivare sempre ad una soluzione qualora essa esista. Essendo ottenere una soluzione lo scopo finale del gioco, non è bene affidarsi al $MinConflict$ senza $RR$, in quanto non ne assicura il raggiungimento.\\

Riassumendo, affermiamo che:
\begin{enumerate}
	\item la risoluzione del problema tramite $DFS$ è generalmente meno efficiente rispetto ad una risoluzione tramite $CSP$. Questo fatto, come appreso durante il corso, non sorprende in quanto $DFS$ non applica nessun tipo di controllo intelligente. Al contrario, $CSP$ riesce tramite l'aggiunta dei giusti vincoli ad eliminare porzioni dello spazio degli stati, ottenendo performance migliori; 

	\item per istanze semplici del problema, il $DFS$ con $CCC$ ha performance migliori di qualsiasi altro solver;
	\item al crescere del numero delle soluzioni del problema, cresce anche la probabilità che $MinConflict$ abbia successo. Quest'ultima conoscenza però non può essere pretesa nella definizione del problema.
\end{enumerate}
\section{Possibili miglioramenti}


Il $CCC$ aiuta sicuramente a diminuire il numero di assegnamenti che non portano ad una soluzione, tuttavia potrebbe essere migliorato non sono controllando la dimensione delle componenti connesse formatosi, ma anche le loro dimensioni. In particolare, una volta che un assegnamento crea più di una componente connessa, si potrebbe gestire quella di più piccola dimensione come un sottoproblema del problema generale, cercando quindi una soluzione per essa. Se tale soluzione non esiste, siamo certi che il valore assegnato alla variabile non porta ad uno stato obiettivo, potendo quindi eliminare il conseguente sottoalbero dallo spazio degli stati.\\
Abbiamo deciso di non implementare questa miglioria nel nostro risolutore in quanto non porterebbe sensibili vantaggi ai nostri solver, visto che il migliore di essi impiega già poco tempo nel raggiungere una soluzione. In caso di istanze molto più complesse, come una griglia più grande, essa risulterebbe molto più utile. 
%**************************************************************

